---
layout: post
title: raft论文翻译
categories: raft
tags:  raft
---

* content
{:toc}

> 我的技术博客，主要是记载看过的书以及对写的好的博客文章的搬运整理，方便自己他人查看，也方便别人指出我文章中的错误，达到一起学习的目的。
> 技术永无止境

本文主要是对raft论文的翻译



## 概括

Raft是一个管理复制日志的一致性算法。它等于与(multi-)Paxos产生一样的结果，而且跟Paxos一样有效，但是他的结构又有点不一样，因此使Raft比Paxos更加好理解和提供一个更好的基础去构建实际系统。为了加强礼节性，Raft分隔一致性的关键元素，例如领导选举，日志复制和安全性，和执行更强的一致性去减少需要考虑的状态数量。Raft同样包含了改变集群成员的新机制，就是通过使用重叠的大多数保证安全性。

## 1 介绍

一致性算法允许一组机器作为一个合作的组合一起工作，即使其中的一些机器会失败。因此，他们在大规模的可信赖的系统中，他们扮演重要角色。在过去十多年期间，Paxos统治了一致性算法的讨论。大部分一致性算法要不是基于Paxos或者受她影响，因此Paxos成为主要的工具用于教授学生一致性。

不行的是，Paxos很难理解，尽管有很多努力想让它更加容易被接受理解。而且，他的结构需要复杂的改变才能用于实际系统。结果就是，系统构建者和学生都要跟Paxos斗争。

在我们与Paxos斗争后，我们出发去查找一个新的一致性算法可以提供更好的基础用于系统构建和教学。我们的方法不同在于，我们的首要目标是易于理解，我们能不能定义一个一致性算法用于实用系统，而且以比Paxos更容易的方式描述？此外，我们想这个算法促进对于系统构建者来说很重的开发直觉。因为不仅仅知道一个算法能够工作很重要，知道它怎样工作一样很重要。

这项工作的结果就是一致性算法Raft.在Raft设计阶段，我们引用特定的技术去提高可理解性，包括分解(Raft分解领导人选举，日志复制和安全性)和状态空间减少（类似于Paxos,Raft降低了非确定性的成都还有服务器与其他服务器保持一致性的方式）

Raft在很多方面跟现存的一致性算法类似，但是他有几个小说特征。

* Stronger leader：Raft使用一个比其他一致性算法更强的领导形式.例如，日志条目只能从领导者流动到其他服务器。这简化了日志条目的管理和使Raft更好理解。
* Leader election:Raft使用一个随机的定时器去选择领导者。这个仅仅在任意一种一致性算法中的心跳增加少量的机制，用于简单和迅速解决冲突。
* Memerbership changes: Raft的机制对于改变集群中的服务器集合，通过使用一个新的共同共识方法，在转变过程中，不同配置的大部分会重叠。这样子允许集群在配置改变时，可以继续工作。

Raft的安全性已经被形式化指定，并被证明，他的效率是可以跟其他算法相当的。

这篇论文的剩下会介绍复制状态机问题(小节2),讨论Paxos的强项和弱项(小节3)，描述一般可理解方法(小节4)，描述Raft一致性算法(小节5-8)，评估Raft（小节9），讨论相关的工作(小节10)


## 2 复制状态机

![](media/15075377647344/15075377791072.jpg)


一致性算法经常在复制状态机的上下文出现。这种方法中，服务器集合上的状态机会计算相同状态的同一拷贝，即使一些服务器down掉，也会不断操作下去。复制状态机是用来解决在分布式系统中一系列的容错问题。例如，拥有唯一一个集群领导的大规模系统，例如GFS，HDFS,都是用一个单独的复制状态机去管理领导选举和存储配置信息，以防领导奔溃。复制状态机的例子包括Chubby和Zookeeper.

复制状态机经常是用一个复制日志实现，如图一一样。每个服务器存储的每条日志都会包含一系列命令，状态机会依次执行这些命令，因此每一个状态机都会处理相同顺序的命令。因为状态机是确定的，所以每个都会计算出相同的状态和相同的输出结果。

保持复制日志的一致性就是一致性算法的工作。服务器的已制定模型就是接受客户端的命令，然后添加到日志。然后他会通过一致性模型去与其他服务器交流，确保每条日志最终都是按照请求顺序排序，即使有些机器失败了。一旦命令正确复制，每个服务器的状态机就会按照日志顺序，去处理他们，并把结果返回到客户端。结果，服务器们形成了一个高可用的状态机。

实用系统的一致性算法一般具有下面特征：

* 在非拜占庭条件下（包括网络延时，分区，包丢失， 冗余，重排序）确保安全性(永远不返回不正确的结果)
* 只要大多数服务器是可以运行，并可以与其他服务器和客户端相互联系，那么这个系统就以完成可用。因此，一个5个服务器组成的集群，最多容忍2个服务器失败。服务器通过暂停来假设失败，他们后面可以通过稳定存储器上的状态恢复过来并重新参与集群。
* 他们不依赖时序去保证日志的一致性。在最坏情况，错误的时钟或者极度的消息延迟会导致可用性问题。
* 一般情况，只要集群中的大多数通过一个远程调用反馈，那一条命令就执行完成了，小数慢的机器不会影响到整个系统的性能。


## 3 what's wrong with paxos?

略


## 4  为了可理解所做的设计

在设计Raft的时候，我们有几个目标，他必须为构建系统提供完整和切实的基础，因为它要显著减少开发者需要设计工作的数量。他必须在所有条件下都是安全，在典型操作条件下都是有效的，而且在常见操作，他必须有效。但是我们最重要的目标，最困难的挑战是，可理解性。对于绝多数的观众，必须可能理解这个算法。另外，必须尽可能开发者了解算法，让系统构建者在实际应用中可以扩展这个算法。


再设计Raft过程中，有很多点我们有很多替代额方法。在这种情况，我们会基于可理解性去评估可替代方法。解释每种替代方法有多难(例如，状态空间有多复杂，它是否有微妙的影响？), 读者是否很容易就完全理解这种方法以及弦外之音。

我们认识到在这样的分析，有很高的主观性。尽管如此，我们使用两种普遍适用的技术。第一种技术就是总所周知的问题分析。尽可能的把问题分解成多个能独立解决，解析和理解的问题。例如，Raft分解成领导人选举，日志复制和安全性，以及成员变化。

第二种方法就是通过减少需要考虑的状态，从而简化状态空间，是的系统更加一致，尽可能消除非确定性。特别的，日志不允许有空洞，Raft限制这种行为，从而消除日志会跟其他服务器上面日志的不一致。尽管在大多数情况下，我们尝试去消除不确定性，但是很多情况下，不确定性可以提高可理解性。在实际上，随机方法引入不确定性，但是他们却他们却以相似的方法处理所有可能的选择，从而减少状态空间。我们使用随机化去简化Raft的领导人选举算法。


## 5 Raft一致性算法

Raft算法是一个管理复制日志的算法，如小节2介绍。图2以概括的形式总结了算法，以便查看，图3列举了算法的关键属性，这些图片上的元素会在该小节后面分段讨论。

Raft实现一致性是首先通过选举一个独一无二的领导者，并给予领导完全的责任去管理复制日志。领导接受来自客户端的日志条目，并复制派发他们到其他服务器，并在可以安全应用这些日志条目到状态机时的时刻告诉服务器们。拥有一个领导，可以简化对复制日志管理。例如，领导不需要跟其他服务器商量就可以确定在日志哪个地方放置新的条目，并且数据是从领导流向到其他服务器这种简单方式。领导可以宕机或者跟其他服务器失联，在这种情况，新的领导就会被选举出来。

鉴于领导的方法，Raft分解一致性算法成三个相关独立的子问题，会在下面小节中讨论。

* 领导人选择：当现存的领导宕机时，新的领导人必须选择出来
* 日志复制: 领导人必须接受客户端的日志条目，复制他们到集群中，迫使其他服务器日志跟自己的日志保持一致。
* 安全性： Raft中关键的安全属性时图3中的状态机安全属性。如果任意一个服务器应用了一个特定的日志条目到状态机，那么就不会有其他服务器在相同的日志索引中应用了不一样的命令。小节5.4就会描述Raft怎样确保这个属性。解决方法涉及到在小节5.2描述的选举机制中加入额外的限制。

在描述完一致性算法后，这些会讨论可用性的问题以及在这个系统中时序的角色。

![](media/15075377647344/15075425142527.jpg)

![](media/15075377647344/15076042712691.jpg)


### 5.1 Raft基础

Raft集群一般拥有几台机器，5台是很经常采用的数目，这样子系统能容忍2台失败。在任何一个时刻，每个服务器都会在三个状态之一：领导，跟随者，或者参与选举者。一般操作，有唯一一个领导者，其他所有服务器都是追随者。跟随者很被动，他们不能发出请求，只能回应来自领导者和候选人的请求。领导人姐却所有来自客户的请求(如果一个客户联系一个跟随者，跟随者会把客户重定向到领导)。第三种状态，候选人，是用来参与新一任领导人选举的，见小节5.2，图4 显示了状态和他们的转变，转变由下面讨论。

![](media/15075377647344/15076049515235.jpg)

![](media/15075377647344/15076050065344.jpg)


Raft把时间划分为任意长度的任期，如图5显示。任期就是连续的数字标记。每次选举开始一次任期，一个或者多个候选人尝试成为新的领导。如果一个候选人赢得这次选举，那么在他剩余的任期中，他将作为一名领导。在某些情况，一次选举会导致选票分散。在这种情况，改任期没有任何领导，一次新的任期(新的选举)会迅速开始。Raft确保每个任期最多一个领导。

不同的服务器可能在不同时间，能观察到不同任期的转变，在某些情况，一个服务器可能没有观察到一次选举或者一次完整的任期。任期在Raft扮演者逻辑时钟的角色，允许服务器去检测到过期的信息，入过期的领导。每个服务器都存储着当前任期的数字`current term`，会随着时间单调递增。`current term`会在服务器交流过程中改变；如果一个服务器`current term`少于另外一个，他就会更新到`current term`最大的那个。如果一个候选人或者领导发现他们的任期过时了，那么他们就会立即转换成跟随者状态。如果一个服务器收到一个来自陈旧任期的请求，他会拒绝这个请求。

Raft服务器使用远程调用RPCs交流，基本的一致性算法只用两种类型的RPCs。请求选票RPCs会在选举时被候选人启动(见小节5.2)，以及附加日志 RPCs会在领导去复制日志条目或者提供心跳时启动(见小节5.3)。(小节7)增加了第三种RPC用来传递服务器中间的快照。服务器在指定时间收不到反馈，就会重新尝试RPCs,他们也会为了更好性能从而并行发出RPCs。


### 5.2 领导选举

Raft使用心跳机制来出发领导选举。当服务器启动，他们是以跟随者的状态启动。只要他收到领导人或者候选者的RPCs，服务器就会一直保持跟随者状态。领导可以发送周期性的心跳(附加日志RPC可以不携带任意日志条目)给所有候选者来维持他们的权威。如果一个候选者在一个时间周期（选举超时）没有收到任意交流，他就会假设没有领导，然后开始新一轮选举去选择新的领导。

去开启一轮选举，一个跟随者增加自身的任期号，然后转变成候选状态。然后它会给自己投一票，然后并行给集群中其他服务器发送请求选票RPC.一个候选者会直到下面三件事情之一发生之前都会保持候选状态：a)她赢的这次选举，b)其他服务器已经变成领导，c)一段时间过去了，还没有胜出者。这些会独立在下面的文章讨论

a)如果一个候选者收到整个集群中绝大多数的服务器中相同任期的选票，他就赢得这次选举。每个服务器以先到先得的原则在给定任期只会投票给最多一个候选者(注意：小节5.4会在投票中增加额外的限制)。主要的规则是为了确保了最多一个候选者可以赢得特定周期的选举(图3的选举安全性)。一旦一个候选者赢得一次选举，他就会成为领导。他会发送心跳信息给其他服务器，从而建立它的权威，并防止新的选举。

b)当等待选票，一个候选者可能会受到声称为领导的候选者发送的日志条目RPC。如果领导的任期（在RPC参数中）至少跟候选者的`current term`一样大，那么候选者就会承认领导是合法的，并返回跟随者状态。如果RPC中的任期比候选者当前的`current term`小，那么候选者就会拒绝这个RPC并继续候选状态。

c)第三种结果就是一个候选者既没有赢得，也没有输掉选举。如果很多跟随者在同一时刻变成候选者，那么选票就会分裂，以至于没有一个候选者得到大多数选票.当这种情况发生，每个候选者会超时，并增加自己任期开启新一轮选举，并启动下一轮请求选票RPC。然而，没有其他措施，分裂选票会导致无限制重复。

Raft使用了一种随机选举超市去确保只要选举很快解决，那么很少机会会分裂选票。为了防止分裂选票，选举超时会从一个固定的时间间隔(例如150-300ms)中随机挑选。这样子扩展服务器，以至于大部分情况只有已给服务器会超时。当一台服务器赢得选举，并在其他服务器超时之前发送萧条。同样的机制用于处理票数分散的情况。每个候选者再一次新选举中，重置一个随机的选举超时。然后在开启新一轮选举前，等待时间逝去；这样子减少在新一轮选举中再一次选票分散的可能。小节9.3展示这种方法会迅速选举到领导人。


### 5.3 日志复制

一旦领导人被选择后，他就会开始服务用户请求。每个客户请求包含一条需要被复制状态机执行的命令。领导会吧这条命令当做一条新条目添加到日志中，然后并行给其他服务器发出日志条目RPCs让他们复制该条目。当条目被安全复制(下面描述)，领导会应用这条目到状态机，并返回执行的结果给客户。如果跟随者奔溃或者运行很慢，又或者网络包丢失，领导会无限次重复日志条目RPCs(即使他已经给客户端反馈)，直到所有跟随者最终都存储相同的日志条目。

![](media/15075377647344/15076147784343.jpg)


日志组织如图6所示，每个日志条目存储一跳状态机命令，伴随着这条条目被领导接受时的任期号。在日志条目上面的任期号码是用来检测日志间的不一致性和确保图三的一些属性。每条日志条目还有一个整数索引，标记他在日志中的位置

领导会决定安全应用一条日志条目到状态机的的时机，这样的条目就会标志为提交的。Raft保证被提交条目已经持久化，病最终会被所有有效的状态机执行。一旦领导创建的日志条目已经复制到集群中的绝大多数服务器(如图6中的条目6)，那么这个日志条目就被提交。同样会提交所有在领导日志中改被提交条目的前面的条目，包括以前领导创建的条目。小节5.4会讨论在领导改变之后，应用这些规则的微妙之处，同样显示提交的定义是安全的。领导会跟踪最高的提交索引，并把这个索引包含在未来的日志条目RPC中(包括心跳),以至于其他服务器可以发现。一旦跟随者知道一条日志条目被提交，就会以日志顺序应用这条条目到本地状态机。

我们设计Raft的日志条目机制，是想维持一个高层次的，在不同服务器中日志保持一致性。不但讲话系统行为，而且让他更加精确，但是保持组件的安全性一样重要。Raft维持跟随者属性，这些属性一起构成了图3的日志匹配属性

* 如果在不同日志中，两个条目有相同的索引和任期，那么他们存储相同的命令。
* 如果不同日志中，两个条目有相同的索引和任期，那么所以之前的条目都是相同的。

第一个特征伴随这个事实，一个领导在给定任期，在给定的日志索引位置，最多创建一条条目。第二个属性通过简单的附加条目的一致性检查保证。当发送一个附加条目RPC，领导会包含新条目之前的条目的索引和任期。如果跟随者没有在日志中找到具有相同索引任期的条目，就会拒绝新的条目。这样的一致性检测作为感应步骤。初始化空的日志状态满足`Log Matching`特征，当任何时候日志需要扩展时，一致性检查会保持`Log Matching`属性。作为结果，任意时刻，附加条目都会成功，领导知道跟随者的日志直到最新添加的日志都跟自身一样。

在一般操作中，领导和跟随者日志保持一致，以至于附加日志一致性检查不会失败。然而，领导会奔溃导致日志不一致(旧的领导没有完全复制它日志中所有条目)。这种不一致会伴随一系列领导和跟随者的宕机而叠加起来。
图7展示了跟随者的日志跟新领导的不一样。一个跟随者可能缺失领导有的日志,也有可能有领导没有的额外条目，或者两者都有。日志中缺失和多余的条目会跨越多个任期。

![](media/15075377647344/15076168031053.jpg)


在Raft, 领导通过强迫跟随者日志去复制自己的来解决一致性。这意味着，跟随者的冲突条目会被来自领导的日志条目覆盖。小节5.4展示再加上一个限制，这就会安全。

为了让跟随者日志跟领导者自身的一样，领导必须找到最新的两者相同的日志条目，然后删除跟随者在这条目后面的所有条目，并领导者发送那个日志点的所有条目给跟随者。所有这些操作发生在附加条目RPC的一致性检查。领导会维持每个跟随者的`nextIndex`,这个索引所在的条目就是领导会发送给跟随者的。当一个领导刚刚当选，会初始化所有的`nextIndex`为日志最后一条的索引+1（图7的11）。如果跟随者的日志跟领导的不一致，那么后续的附加条目RPC会失败。在被拒绝后，领导会减少`nextIndex`直到领导者和跟随者相应条目匹配。。当满足上面条件发生时，附加条目会成功，删除跟随者所有冲突的条目，并添加领导的条目。一旦附加日志成功，跟随者日志会跟领导者一致，并在任期剩下的时间一直保持一致。

如果期望协议可以优化减少拒绝的附加条目的RPC次数。例如，当拒绝附加日志请求，跟随者包含冲突条目的任期以及该任期最早的存储索引。有这些信息，领导可以绕过该任期冲突的条目去减少`nextIndex`.一次附加条目RPC只需要对应一次带有冲突条目的任期，而不是一次RPC对应一条条目。在实践中，我怀疑这种优化是必要，因为失败发生不频繁，不太可能有太多不一致性条目。

有了这种机制，领导不需要在当选时，采取任意操作去保持日志一致性。他只是正常开始工作，日志自动收敛以相应附加条目一致性检查的失败。一个领导永远不会阀盖或者删除自己的日志条目(图三的 Leader Append-Only属性)

日志复制机制展示了小节2锁希望的一致性属性。只用到大多数服务器运行，Raft可以接受，复制，并应用这些新的日志条目。一般情况下，一条新的条目会在一轮RPC中复制到集群中的大多数机器中，一台慢的跟随者不会影响性能。


### 5.4 安全性

前面小节描述了Raft怎样选择领导人和复制日志条目。热俺儿这些机制机制描述还没足够充分保证每个状态机以同样顺序运行相同命令。例如，一个跟随者可能在领导提交几条日志条目时失效，然后当他被选择为领导者，就会覆盖所有新的的条目。作为结果，不同状态机就会有不同运行结果。

这一节会通过在选择领导上增加限制来完整Raft算法。这个限制确保任意给定任期的领导会包含以前任期提交的所有条目(图三的Leader Completeness属性)，给去这样的选举限制，我们可以制定提交规则更加精确。最后，我们展示一个对于Leader Completeness属性的证明草图，并展示如何导致复制状态机的正确行为。

#### 5.4.1 选举限制

任意基于领导的一致性算法，领导必须最终存储所有提交的日志条目。在一些一致性算法，例如Viewstamped Replication，领导即使没有包含所有提交条目也可以被选举。这些算法那包含额外机制去坚定丢失的条目，病传递他们到新的领导，可能在选举过程或者短暂之后。不幸的是，这个结果考虑需要额外机制和复杂性。Raft使用一种简单的方法去保证所有来自前一次任期的提交条目会呈现在选举出来的每个新领导，而不需要将这些条目转移到领导。这意味着日志条目只能够单向流动，从领导到跟随者，且领导永远不会覆盖日志中存在的条目。


Raft使用投票过程来来保证只有当一个候选者拥有所有提交条目才有机会赢得选举。一个候选者必须联系集群中的大多数才能完成选举，这意味着，对于每一个被提交的条目都必须出现在这些服务中的至少一个。如果一个候选者的日志至少跟大多数的任意一台的日志一样up-to-date(下面定义）,那他就拥有全部提交条目。请求票RPC实现这种限制。RPC包含候选者的日志，如果投票者的自身日志比候选者的更新，就会否决该票。

Raft通过比较日志里最后一条条目的索引和任期来比较两个日志谁更up-to-date。如果日志最后一条条目有不同任期，任期数字大的更新。如果日志以相同任期结束，那么那个日志更长就是更新。

![](media/15075377647344/15076208433218.jpg)

#### 5.4.2 旧任期的提交条目

正如小节5.3描述的，领导知道，只要一个条目存储在大多数条目，当前任期的条目就会被提交。如果一个领导在提交日志之前奔溃，未来的领导会尝试完成复制条目。然而，领导不能立即断定，在上个任期的条目被储存在大多数机器时就被提交。图8展示了一种情况，存储在大多数机器的老条目，最终还是被后来的领导覆盖。

为了消除图8所示的问题。Raft不在通过数拷贝数量去提交旧任期的条目。只有当前任期的旧条目是通过数拷贝数去提交。一单当前任期的条目以这种方式提交，因为Log Matching属性，前面的条目都被间接提交。有一些情况领导可以推断出旧条目已经被提交(例如，条目被储存到所有服务器上),但是Raft为了简单采取一种更加保守的方法。

因为当领导复制之前任期的条目，日志条目会保留之前的任期，因此Raft会在提交规则上引入额外的复杂。在其他一致性算法，如果一个新领导从以前的任期复制条目，他必须将这些条目赋予新的任期数。Raft方法使得更容易理解日志条目，因为随着时间和跨越日志，他们都会维持相同的任期号。额外，在Raft的领导会被其他算法发送更少量的以前任期的条目(其他算法在提交他们前，必须发送冗余的日志条目去重新编排他们)


#### 5.4.3 Safety argument

为了完成Raft算法，我们现在讨论Leader Completeness属性的精确定义(这个讨论是基于安全证明，见小节9。2)。我们假设Leader Completeness不具备，然后证明矛盾。假设一个任期T的领导leaderT在它任期提交了一条条目，但是该日志条目并没有被其他未来任期的领导储存。现在考虑最小的任期U>T,领导leaderU没有存储这条目


![](media/15075377647344/15076247411188.jpg)


1. 在选举时，该提交条目肯定不存在leaderU的日志中(领导永远不会删除或者覆盖条目)
2. leaderT复制这条条目到绝大多数机器。然后，至少一台服务器(投票者)既接受来自leaderT的条目，也投票给leaderU,入图9所示。这个投票者是找出矛盾的关键。
3. 投票者肯定在投票给leaderU之前接受了leaderT的提交条目，否则，他会拒绝来自leaderT的附加条目(他的当前任期会比T高)
4. 当他投票给leaderU时，投票者仍然存储改条目，因为每个介入的领导都包含这条条目（假设）,领导不会 移除条目和跟随者只会在跟领导冲突时移除条目。
5. 投票者投票给leaderU,因此leaderU的日志肯定至少跟投票者的一样新。这样子会导致两个矛盾中的一个。
6. 首先，如果投票者和leaderU共享最后条目任期，然后，leaderU的日志至少比投票的日志长，因为领导日志包含投票者的日志。这就是一个矛盾，因为投票者拥有leaderU假设没有的提交条目。
7. 否则，leaderU的最后日志任期必须大于投票者的。此外，因为投票者的最后日志任期至少是T(因为包含了任期T提交的条目)。早任领导创建leaderU的最后一条日志条目必须包含已经提交的条目在他的日志中(通过假设). 但是，通过Log Matching属性，leaderU必须包含已经提交的条目，这里导致矛盾。
8. 这里完成矛盾，因此，所有任期大于T的领导必须包含所有在任期T提交的条目
9. Log Matching属性保证未来的领导会间接包含已经提交的，例如图8的索引2.

有了Leader Completeness属性，我可以可以从图3证明State Machine Safety属性，因为如果一个服务里在状态机的给定索引位置引用一条日志条目，那样子没有别的服务器能在同一个索引应用这条日志索引。当服务器应用一跳日志条目到状态机，他的日志必须跟领导人的日志同步，并且条目被提交。现在考虑低任期的任意服务器应用了一条给定索引的日志，Log Completeness属性保证高任期的所有领导者都会存储相同的日志条目，所以服务器在后面的任期应用改索引也会应用到相同的值。因此，State Machine Safety属性得证。

最后，Raft需要服务器以日志索引顺序应用条目。结合State Machine Safety属性，这意味着全部服务器会以相同顺序应用准确相同的日志条目集合到他们的状态机。


### 5.5 跟随者和候选者宕机

直到仙子，我们都是充电在领导失败，跟随者和候选者宕机比处理领导者宕机简单多，他们都可以以相同方式处理。如果一个候选者或者跟随者当家，未来发送他的请求投票和附加条目RPC都会失败。Raft处理这些失败是通过不断尝试，如果崩溃的服务器重新启动，然后RPC就会成功完成。如果服务器在完成RPC请求，在响应之前崩溃，那么他在启动后就会收到相同的RPC。Raft的RPC是幂等的，所以这不会导致啥问题。举个例子，如果一个跟随者收到一个附加条目请求，其中包含了已经在日志中的条目，他就会新的请求中忽略这些条目。

### 5.6 时间和可用性

我们对Raft的一个需求就是安全性不能依赖于时序。系统不能因为一些时间发生比我们预期快或者慢导致生成不正确的结果。然而，可用性(系统及时响应给客户的能力)必须不可避免依赖于时间。举个例子，如果消息交换的时间比服务器之间的崩溃的典型时间要长，候选者就没法简直足够唱的时间赢取这次选举。没有一个稳定的领导，Raft就不能取得进展。

领导选举是Raft中时间方面最关键的。Raft要保证选举和维持一个稳定的领导使得系统满足下面的时间需求。
`broadcastTime << electionTimeout << MTBF` 不等的广播时间是平均时间，参照服务器并行发送RPC请求给集群中的每个服务器并接收到他们请求。选举时间超时在小节5.2描述，MTFB是对于一台服务器失败的平均时间。广播时间应该一个数量级小于选举超时，以此领导可以可信的发送心跳信息自动开始选举后的跟随者。给与随机方法应用到选举超时，不等性可以是选票分散不太可能。选举超时应该也是比MTBF时间少于几个数量级的，因此使系统稳定进行。当领导崩溃，系统会在大概选举超时的时间内不可用，我们希望他只是占了所有时间的一小片段。

广播时间和MTBF是底层系统的属性，然而选举时间是我们必须选择的。Raft的RPC典型需要接受者持久化信息到稳定存储器，所以广播时间可能跨越0.5ms到20ms之间，依赖于存储技术。作为结果，选举超时可能会在10ms到500ms之间。典型的服务器的MTBF应该几个月或者更长，因此很容易满足时间需求。

## 6 集群成员变更

直到目前，我们假设集群的配置是固定的。实际上，某些场景有必要改变配置。举个例子，替换失败的服务器或者改变复制成都。尽管可以让整个集群离线，更新配置文件，然后重新启动集群，这样子会让集群在更换期间不可用。另外，存在任意手动步骤，都会存在操作错误的冒险。为了避免存在问题，我们决定自动化配置并合并他们到Raft一致性算法中。

为了配置改变机制安全，在过渡期间，如果可能在同一任期存在两个领导，就会变成没意义。不幸的是，任意方法服务器直接从旧配置前换到新配置都是不安全。不可能同一时间自动切换所有服务器，因此服务器可能存在在过渡期间分裂成两个独立的大多数(如图10所示)

![](media/15075377647344/15081250583812.jpg)

为了确保安全性，配置改变必须使用两阶段的方法。有一系列方法实现两阶段。举个例子，一些系统使用第一阶段去禁用旧配置，让她不再处理用户请求。然后第二阶段启用新配置。在Raft中，集群首先切换到过渡配置，我们成为`joint consensus`.一旦共同共识被提交，系统就会过渡为新配置。共同共识结合了旧和新的配置：

* 日志条目会复制给所有配置信息的服务器上。
* 任意配置信息上的服务器都可以作为服务器
* 同意(选举和条目提交)需要新旧配置上的分开的大多数

共同共识允许独立的服务器在不同时间上配置信息上进行转变而无需安全性。而且允许群集在配置变化时不断服务用户请求。

![](media/15075377647344/15081299679107.jpg)


集群配置是以复制日志中使用特殊的条目存储和交流。图11阐述了配置改变的过程。当领导人收到一个把配置从Cold到Cnew的请求是，他会以日志条目存储这个配置，并使用前面所述的机制复制它，为了共同共识。一旦一台服务器存储了增加了新的配置条目到日志中，他会在以后所有决定中使用该配置（服务器经常使用日志中最新的配置，不管这条日志是否提交）这意味着当Cold,new条目提交时，领导会用Cold,new去决定。如果领导崩溃，新领导就会在Cold或者Cold,new中选择，取决于赢得候选的有没有接收到Cold,new。在任意情况，Cnew在这期间不能单方面决定。

一旦Cold,new被提交，Cold和Cnew都不能未经另外一方许可就做出决定，leader completeness属性保证只有有Clod,new日志条目的服务器可以被选举为领导人。现在就可以很安全让领导去创建描述Cnew的的日志条目并复制他到集群中。再次，这个配置会慢慢在每一台机器中有效。在Cnew规则下，新配置被提交，旧的配置就不相干，不在新配置的就服务器就会关闭。正如图11所示，没有时间是Cold和Cnew在一起时可以单方面做决定。这样保证安全。

再重新配置中有三个问题需要解决。第一个问题是新服务器可能没有初始化任何日志条目。如果他们一这个状态加入到急群众，可能需要花费相当大的时间去更上进度，在这段时间，他们就不可能提交新的日志条目。为了避免有效间隔，Raft在配置变更前引入一个额外的阶段，新服务器加入到集群时，以非投票成员形式存在(领导会复制日志条目给他们，但是他们不会考虑为大多数)。一旦新服务器赶上集群中的大多数，重新配置就会像上面描述那样进行。

第二问题是集群领导可能不是新配置的一员。这种情况，领导一旦提交Cnew日志条目，领导就会下台(转变成跟随者状态)。这意味着，存在一段时间（当他正在提交Cnew）领导管理的集群并不包含自己,他复制日志条目，但是统计数目时却不计算自己算作大多数。当Cnew提交时，领导转变发生，因为这是新配置可以独立操作的第一个关键点(总是可以从Cnew配置中选择领导)。在这个点之前，可能一台来自Cold的服务器可以作为选择领导人。

第三个问题是移除的服务器(不在Cnew)可能会破坏集群。这些服务器接受不来心跳，因此他们会超时，然后发起新选举。然后他们会以新任期数字发起请求投票RPC，这样子会导致新人领导转变成跟随状态。新任领导最终会被选举，但是是移除的服务器会再次超时，然后这个过程会重复，导致低可用性。

为了防止这个问题，当服务器想想当前领导人存在时，服务器会忽略请求选票RPC。特别的，如果一个服务器在最小选举超时时间内收到现在领导的请求选票RPC，他不会更新自己任期以及给与它选票。这样子不会影响正常选票，每个服务器在开始选举前，至少等待最小选举时间超时。然而，这样子有足浴我们避免来与移除服务器的中断。如果一个领导可以获得集群的心跳，他就不会被更到任期的数字所取代。

## 7 日志压缩

Raft的日志随着正常操作增长，以包含更多客户请求。但是在实际系统，他不可能没限制增长。当日志增长够长时，他会占据更多空间，并花费更多时间去重播。如果没有一些机制抛弃在日志中累计的信息，这样子最终导致可用性问题。

快照就是最简单的方法区压缩。在快照中，整个当前系统状态会作为一个快照写入到稳定存储器，然后到该点之前的日志都会被抛弃。快照应用在Chubby和Zookeeper中，剩下的该节会描述Raft的快照。

增量压缩的方法，例如日志清理或者日志结构合并树，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了 压缩的负载压力。首先，他们先选择一个已经积累的大量已经被删除或者被覆盖对象的区域，然后重写那个区域还活跃的对 象，之后释放那个区域。和简单操作整个数据集合的快照相比

![](media/15075377647344/15081355676313.jpg)

图 12 展示了 Raft 中快照的基础思想。每个服务器独立的创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状 态写入到快照中。Raft 也包含一些少量的元数据到快照中：最后被包含索引指的是被快照取代的最后的条目在日志中的索引值 （状态机最后应用的日志），最后被包含的任期指的是该条目的任期号。保留这些数据是为了支持快照后的第一个条目的附加条目请求时的一致性检查，因为这个条目需要最后的索引值和任期号。为了支持集群成员更新（第 6 节），快照中也将最后的一次配置作为最后一次条目存下来，一旦服务器完成一次快照，他就可以删除最后索引之前的所有日志和快照了。

一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。

尽管通常服务器都是独立的创建快照，但是领导人必须偶尔的发送快照给一些落后的跟随者。这通常发生在当领导人已经丢弃 了下一条需要发送给跟随者的日志条目的时候。幸运的是这种情况不是常规操作：一个与领导人保持同步的跟随者通常都会有 这个条目。然而一个运行非常缓慢的跟随者或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让这个跟随者更新到 最新的状态的方式就是通过网络把快照发送给他们。

![](media/15075377647344/15081360935419.jpg)


在这种情况下领导人使用一种叫做安装快照的新的 RPC 来发送快照给太落后的跟随者；见图 13。当跟随者通过这种 RPC 接 收到快照时，他必须自己决定对于已经存在的日志该如何处理。通常快照会包含没有在接收者日志中存在的信息。在这种情况 下，跟随者直接丢弃他所有的日志；这些会被快照所取代，但是可能会和没有提交的日志产生冲突。如果接收到的快照是自己 日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照之后的条目必须正确和保留。

这种快照的方式背离了 Raft 的强领导人原则，因为跟随者可以在不知道领导人情况下创建快照。但是我们认为这种背离是值得 的。领导人的存在，是为了解决在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，这时不存在冲突了， 所以没有领导人也是可以的。数据依然是从领导人传给跟随者，只是跟随者可以重新组织他们的数据了。 我们考虑过一种替代的基于领导人的快照方案，即只有领导人创建快照，然后发送给所有的跟随者。但是这样做有两个缺点。 第一，发送快照会浪费网络带宽并且延缓了快照处理的时间。每个跟随者都已经拥有了所有产生快照需要的信息，而且很显 然，自己从本地的状态中创建快照比通过网络接收别人发来的要经济。第二，领导人的实现会更加复杂。例如，领导人需要发 送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。

还有两个问题影响了快照的性能。首先，服务器必须决定什么时候应该创建快照。如果快照创建的过于频繁，那么就会浪费大 量的磁盘带宽和其他资源；如果创建快照频率太低，他就要承受耗尽存储容量的风险，同时也增加了从日志重建的时间。一个 简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置的显著大于期望的快照的大小，那么 快照对磁盘压力的影响就会很小了。

第二个影响性能的问题就是写入快照需要花费显著的一段时间，并且我们还不希望影响到正常操作。解决方案是通过写时复制 的技术，这样新的更新就可以被接收而不影响到快照。例如，具有函数式数据结构的状态机天然支持这样的功能。另外，操作 系统的写时复制技术的支持（如 Linux 上的 fork）可以被用来创建完整的状态机的内存快照（我们的实现就是这样的）。

## 8 客户端交互

8 客户端交互

这一节将介绍客户端是如何和 Raft 进行交互的，包括客户端如何发现领导人和 Raft 是如何支持线性化语义的。这些问题对于 所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。 Raft 中的客户端发送所有请求给领导人。当客户端启动的时候，他会随机挑选一个服务器进行通信。如果客户端第一次挑选的 服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供他最近接收到的领导人的信息（附加条目请求包含了领导人 的网络地址）。如果领导人已经崩溃了，那么客户端的请求就会超时；客户端之后会再次重试随机挑选服务器的过程。 我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在他调用和收到回复之间）。但是，如上述，Raft 是可以执行同一条命令多次的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新 的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然 后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结 果，而不重新执行指令。

只读操作可以直接解决而不需写入任何东西到日志中。然而，没有额外的措施，这样子会冒着返回脏数据的风险，因为相应这个请求的领导不知道他已经被一个新领导取代。线性读必须不能返回陈旧数据，因此Raft在不使用日志情况下需要两个额外注意事项。第一，领导必须拥有最近提交的日志条目的信息，Leader Complteness属性保证一个领导具有所有提交条目，但是在他的任期的开始，他不知道哪些是。为了找出来，他需要在他的任期提交一条条目。Raft通过在他的任期的开始，让每台服务器提交一跳空的没操作的条目到日志中。的任期里提交一条日志条目。Raft 中通过领导人在任期开始的时候提交一个空白的没有任何操作的日志条目 到日志中去来实现。第二，领导人在处理只读的请求之前必须检查自己是否已经被废黜了（他自己的信息已经变脏了如果一个 更新的领导人被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这 个问题。可选的，领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时间来保证安全性（假设时间误差是有界的）。



